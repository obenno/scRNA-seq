---
title: "ThunderBio VDJ Report"
date: "`r Sys.Date()`"
output: 
  flexdashboard::flex_dashboard:
    vertical_layout: scroll
    orientation: rows
    theme: 
      bootswatch: flatly
      version: 5
params:
  sampleName : "sampleName"
  qualimap_out : "rnaseq_qc_results.txt"
  qualimap_gene_coverage : "qualimap_gene_coverage.txt"
  starsolo_matrixDir: "sample/Gene/filtered"
  starsolo_out : "Summary.csv"
  starsolo_bc : "UMIperCellSorted.txt"
  saturation_json: "saturation_out.json"
  version_json: "versions.json"
  nCPUs: 10
  nMem: 10000000000.0
  nFeature_RNA_lower: 200
  percent_mt_cutoff: 100
  pca_dim: 30
  resolution: 0.8
  VDJ_B_report: "VDJ_B_report.tsv"
  VDJ_B_airr: "VDJ_B_airr.tsv"
  VDJ_B_kneeOut: "VDJ_B_kneeOut.tsv"
  VDJ_B_finalOut: "VDJ_B_finalOut.tsv"
  VDJ_B_cells: "VDJ_B_cells.tsv"
  VDJ_B_metrics: "VDJ-B_metrics.json"
  VDJ_B_cloneType : "VDJ-B.cloneType.tsv"
  VDJ_T_report: "VDJ_T_report.tsv"
  VDJ_T_airr: "VDJ_T_airr.tsv"
  VDJ_T_kneeOut: "VDJ_T_kneeOut.tsv"
  VDJ_T_finalOut: "VDJ_T_finalOut.tsv"
  VDJ_T_cells: "VDJ_T_cells.tsv"
  VDJ_T_metrics: "VDJ-T_metrics.json"
  VDJ_T_cloneType: "VDJ-T.cloneType.tsv"
  withUMI: TRUE
---

```{css echo = FALSE}
.chart-title {
  font-size: 1.2rem;
  font-weight: 700;
  margin-left: 10px;
  margin-right: 10px;
}
```

```{js echo = FALSE}
// shrink navbar height
document.querySelector(".navbar").classList.add("pt-1")
document.querySelector(".navbar").classList.add("pb-1")
```

```{r include=FALSE}
library(tidyverse)
library(scales)
library(flexdashboard)
library(jsonlite)
library(DT)
##library(htmlwidgets)
library(plotly)
library(kableExtra)
library(Seurat)
library(future)
library(SeuratDisk)
##library(VennDiagram)
library(Biostrings)
library(data.table)
library(matrixStats)
library(reshape2)
library(ComplexHeatmap)
library(seqinr)
library(stringi)

set.seed(1234)
plan(multisession, workers = as.numeric(params$nCPUs))
options(future.globals.maxSize = as.numeric(params$nMem), sass.cache = FALSE)
RhpcBLASctl::blas_set_num_threads(1) # https://github.com/satijalab/seurat/issues/3991

## Rmd options
knitr::opts_chunk$set(
  comment = '', fig.retina = 4,
  warning = FALSE, message = FALSE
)


config_plotly_fig <- function(fig, ...){
    config(
        fig,
        displaylogo = FALSE, 
        modeBarButtonsToRemove = c('zoom', 'pan', 'select', 'zoomIn', 'zoomOut', 'autoScale',
                                   'hoverClosestCartesian', 'hoverCompareCartesian'),
        toImageButtonOptions = list(height= NULL, width= NULL, scale= 2),
        ...
    )
}

## define info icon funciton
infoIcon <- function(info,
                     class = "fa fa-info-circle",
                     style="font-size: 1.25rem; color: #545b62;"){
  ## Make HTML
  outTag <- paste0('<i class="',
                   class,
                   '" aria-hidden="true" ',
                   'data-tippy-content="',
                   info,
                   '" ',
                   'style="',
                   style,'"></i>')
  return(HTML(outTag))
}


## decide whether to incldue each page
## conditional page solution is from: https://stackoverflow.com/questions/59202693/how-can-i-create-a-conditional-flexdashboard-layout
if(is.null(params$starsolo_matrixDir) || params$starsolo_matrixDir == "") {
    include_gex <- FALSE
}else{
    include_gex <- TRUE
}
if(is.null(params$VDJ_T_metrics) || params$VDJ_T_metrics == "") {
    include_tcr <- FALSE
}else{
    include_tcr <- TRUE
}
if(is.null(params$VDJ_B_metrics) || params$VDJ_B_metrics == "") {
    include_bcr <- FALSE
}else{
    include_bcr <- TRUE
}


## Note since GEX data only support UMI, so include_gex requires withUMI == TRUE
if(include_gex && !params$withUMI){
    stop("GEX data requires library structure containing UMI")
}
```

```{r include = FALSE}
## lineage stats
## get lineage information
## defined as the same VDJ segements, identical CDR3 length and > 80% CDR3 nt identity
getLineage <- function(cells, barcode_report){
    d <- read_tsv(barcode_report) %>%
        dplyr::rename("barcode" = "#barcode") %>%
        select(barcode, chain1, chain2) %>% 
        filter(barcode %in% cells) %>%
        filter(chain1 != "*", chain2 !="*")
    
    d$chain1_V <- strsplit(d$chain1,",") %>% sapply("[",1) %>% str_remove("\\*[0-9]+$")
    d$chain1_D <- strsplit(d$chain1,",") %>% sapply("[",2) %>% str_remove("\\*[0-9]+$")
    d$chain1_J <- strsplit(d$chain1,",") %>% sapply("[",3) %>% str_remove("\\*[0-9]+$")
    d$chain1_cdr3 <- strsplit(d$chain1,",") %>% sapply("[",5)
    
    d$chain2_V <- strsplit(d$chain2,",") %>% sapply("[",1) %>% str_remove("\\*[0-9]+$")
    d$chain2_D <- strsplit(d$chain2,",") %>% sapply("[",2) %>% str_remove("\\*[0-9]+$")
    d$chain2_J <- strsplit(d$chain2,",") %>% sapply("[",3) %>% str_remove("\\*[0-9]+$")
    d$chain2_cdr3 <- strsplit(d$chain2,",") %>% sapply("[",5)
    
    d0 <- d %>% mutate(cdrh3_len = str_length(chain1_cdr3)) %>%
        group_by(chain1_V, chain1_D, chain1_J, chain2_V, chain2_D, chain2_J, cdrh3_len) %>% 
        group_split()
    
    d_single <- d0[sapply(d0, nrow)==1]
    d_multiple <- d0[sapply(d0, nrow)>1]
    
    d_multiple_final <- list()
    for(i in 1:length(d_multiple)){
        
        k <- d_multiple[[i]] %>% pull(chain1_cdr3)
        aln <- as.alignment(nb = length(k), nam = 1:length(k), k)
        aln_dist <- dist.alignment(aln, matrix = "identity",gap = T) %>% as.matrix()
        identityM <- 1-aln_dist^2
        
        tr <- hclust(as.dist(1-identityM))
        ## use cutree to define families, cutoff is 0.2 (80% identity)
        familyIdx <- cutree(tr, h=0.2)
        
        if(length(unique(familyIdx))==1){
            d_multiple_final[[length(d_multiple_final)+1]] <- d_multiple[[i]]
        }else{
            m <- d_multiple[[i]] %>%
                mutate(family=as.character(familyIdx)) %>%
                ungroup() %>%
                group_by(family) %>%
                group_split(.keep = FALSE)
            for(u in 1:length(m)){
                if(nrow(m[[u]])>1){
                    d_multiple_final[[length(d_multiple_final)+1]] <- m[[u]]
                }else{
                    d_single[[length(d_single)+1]] <- m[[u]]
                }
            }
        }
    }
    
    singleInfo <- list()
    for(i in 1:length(d_single)){
        singleInfo[[i]] <- d_single[[i]] %>%
            mutate(lineageType = "single",
                   lineageName = paste0("LS", i))
    }
    
    multipleInfo <- list()
    for(i in 1:length(d_multiple_final)){
        multipleInfo[[i]] <- d_multiple_final[[i]] %>%
            mutate(lineageType = "multiple",
                   lineageName = paste0("LM", i))
    }
    
    single_df <- do.call(bind_rows, singleInfo)
    multiple_df <- do.call(bind_rows, multipleInfo)
    lineageInfo <- bind_rows(single_df, multiple_df)
    return(lineageInfo)
}
```


```{r include = FALSE}
## https://liulab-dfci.github.io/RIMA/Repertoire.html#tcr-and-bcr-entropy-and-clonality
## function to calculate Shannon entropy and clonality

```


```{r include = FALSE}
## VDJ coverage function
## contributed by Yuanzhen (yuanzhen@thunder-bio.com)
plot_VDJ_coverage <- function(cells, barcode_report, airr_report, trust4_final_out, type = "VDJ-B"){
  
  cell_report <- read_delim(barcode_report,
                            delim = "\t", escape_double = FALSE,
                            trim_ws = TRUE) %>% 
    dplyr::rename(barcode=`#barcode`) %>%
    filter(barcode %in% cells)
  d <- cell_report %>% select(barcode, chain1, chain2)
  d$chain1_contig <- strsplit(d$chain1,",") %>% sapply("[", 8)
  d$chain2_contig <- strsplit(d$chain2,",") %>% sapply("[", 8)
  airr <- read_delim(airr_report, 
                     delim = "\t", escape_double = FALSE,
                     trim_ws = TRUE)
  
  VDJ_final_matrix=fread(trust4_final_out,
                         sep="",
                         header = F)
  
  name_fi_=VDJ_final_matrix$V1 %>% str_remove_all(">") %>% str_remove_all("\\s[A-Z]+.*")
  
  chain1_info <- airr %>% select(sequence_id, sequence, junction, cdr1, cdr2) %>% 
    filter(sequence_id %in% na.omit(d$chain1_contig)) %>% filter(str_length(junction)>4)
  chain2_info <- airr %>% select(sequence_id, sequence, junction, cdr1, cdr2) %>% 
    filter(sequence_id %in% na.omit(d$chain2_contig)) %>% filter(str_length(junction)>4)
  
  if(type == "VDJ-B"){
    p1 <- .vh_vl_plot(vdj_type = "BCR_VH", chainInfo = chain1_info, name_fi = name_fi_)
    p2 <- .vh_vl_plot(vdj_type = "BCR_VL", chainInfo = chain2_info, name_fi = name_fi_)
  }else if(type == "VDJ-T"){
    p1 <- .vh_vl_plot(vdj_type = "TCR_VH", chainInfo = chain1_info, name_fi = name_fi_)
    p2 <- .vh_vl_plot(vdj_type = "TCR_VL", chainInfo = chain2_info, name_fi = name_fi_)
  }
  
  plotList <- list(chain1_plot = p1, chain2_plot = p2)
  
  return(plotList)
}


extract_cdr_start <- function(vdj_seq, cdr_seq){
    stri_locate_last(vdj_seq, regex = cdr_seq)[1]
}

extract_cdr_end <- function(vdj_seq, cdr_seq){
    stri_locate_last(vdj_seq, regex = cdr_seq)[2]
}

.vh_vl_plot=function(vdj_type, chainInfo, name_fi){
  
  chainInfo=chainInfo[!is.na(chainInfo$junction), ]
  ## Remove cells with too short cdr3 (4nt)
  chainInfo <- chainInfo %>%
      filter(str_length(junction)>4)
  
  if(nrow(chainInfo)==0){
    stop("your VDJ do not complete(not have cdr3 at least)")
  }
  
  ## generate cdr start and end
  chainInfo$cdr1_start <- map2_int(chainInfo$sequence, chainInfo$cdr1, .f = extract_cdr_start)
  chainInfo$cdr1_end <- map2_int(chainInfo$sequence, chainInfo$cdr1, .f = extract_cdr_end)
  chainInfo$cdr2_start <- map2_int(chainInfo$sequence, chainInfo$cdr2, .f = extract_cdr_start)
  chainInfo$cdr2_end <- map2_int(chainInfo$sequence, chainInfo$cdr2, .f = extract_cdr_end)
  chainInfo$cdr3_start <- map2_int(chainInfo$sequence, chainInfo$junction, .f = extract_cdr_start)
  chainInfo$cdr3_end <- map2_int(chainInfo$sequence, chainInfo$junction, .f = extract_cdr_end)
  
  chain_locate=match(chainInfo$sequence_id, name_fi)
  
  
  #B cell  IMGT numbering
  #
  #IGHV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-115
  #
  #IGKV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-1100
  #
  #
  #IGLV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-115
  #
  #
  # more information about B cell numberiing https://www.imgt.org/IMGTScientificChart/Numbering/IMGT-Kabat_part1.html
  #
  #T cell IMGT numbering
  #
  #TRBV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-109
  #
  #
  #TRAV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-107
  #
  #TRDV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-108
  #
  #
  #TRGV
  #cdr1:27-38
  #cdr2:56-65
  #cdr3:105-109
  #
  #
  #more information about T cell numberiing:https://www.imgt.org/IMGTScientificChart/Numbering/IMGT-Kabat_part2.html
  #
  if(vdj_type=="BCR_VH"){
    cdr1_start=27
    cdr1_end=38
    cdr2_start=56
    cdr2_end=65
    cdr3_start=105
    cdr3_end=115
  }else if(vdj_type=="BCR_VL"){
    cdr1_start=27
    cdr1_end=38
    cdr2_start=56
    cdr2_end=65
    cdr3_start=105
    cdr3_end=115
  }else if(vdj_type=="TCR_VH"){
    ## used TRB location as representative
    cdr1_start=27
    cdr1_end=38
    cdr2_start=56
    cdr2_end=65
    cdr3_start=105
    cdr3_end=109
  }else if(vdj_type=="TCR_VL"){
    ## used TRA location as representative
    cdr1_start=27
    cdr1_end=38
    cdr2_start=56
    cdr2_end=65
    cdr3_start=105
    cdr3_end=109
  }else{
    errorCondition("your vdj_type not correctly, please use VH or VL")
  }
  
  ## Align sequences
  convert_position <- function(imgt_cdr3_aa_start, cdr3_start, seq_position){
      return(seq_position + as.integer(imgt_cdr3_aa_start) * 3L - cdr3_start)
  }
  
  ## Do not use pmap_int() here!
  ## Note 3L above
  chainInfo$cdr1_start_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, chainInfo$cdr1_start), .f = convert_position)
  chainInfo$cdr1_end_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, chainInfo$cdr1_end), .f = convert_position)
  chainInfo$cdr2_start_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, chainInfo$cdr2_start), .f = convert_position)
  chainInfo$cdr2_end_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, chainInfo$cdr2_end), .f = convert_position)
  chainInfo$cdr3_start_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, chainInfo$cdr3_start), .f = convert_position)
  chainInfo$cdr3_end_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, chainInfo$cdr3_end), .f = convert_position)
  chainInfo$seq_start_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, rep(1, nrow(chainInfo))), .f = convert_position)
  chainInfo$seq_end_aligned <- pmap_dbl(list(cdr3_start, chainInfo$cdr3_start, str_length(chainInfo$sequence)), .f = convert_position)

  chain_count <- lapply(1:length(chain_locate), function(i){
    nt_1_weight <- name_fi[chain_locate[i]+2] %>% str_split(" ") %>% unlist() %>% as.numeric()
    nt_2_weight <- name_fi[chain_locate[i]+3] %>% str_split(" ") %>% unlist() %>% as.numeric()
    nt_3_weight <- name_fi[chain_locate[i]+4] %>% str_split(" ") %>% unlist() %>% as.numeric()
    nt_4_weight <- name_fi[chain_locate[i]+5] %>% str_split(" ") %>% unlist() %>% as.numeric()
    nt_weight_matrix <- matrix(
        c(nt_1_weight, nt_2_weight,
          nt_3_weight, nt_4_weight),
        nrow=4,
        byrow = T
    )
    nt_depth <- nt_weight_matrix %>% colMaxs(na.rm = T)
    seq_len <- str_length(nt_depth)
    ## Add NA to depth if the sequence is not complete VDJ
    if(chainInfo$seq_start_aligned[i] > 0){
        ## Add NA if the sequence is not from 0
        nt_depth <- c(rep(NA,  chainInfo$seq_start_aligned[i] - 1), nt_depth)
    }else{
        ## or trim first several nt with minus position
        nt_depth <- nt_depth[(1-chainInfo$seq_start_aligned[i]):length(nt_depth)]
    }
    ## set max length to 120*3
    if(120*3 - chainInfo$seq_end_aligned[i] > 0){
        nt_depth <- c(nt_depth, rep(NA, 120*3 - chainInfo$seq_end_aligned[i]))
    }else{
        nt_depth <- nt_depth[1:(120*3)]
    }
  })
  
  chain_dt=do.call(rbind,chain_count)
  chain_dt[is.na(chain_dt)] <- 0

  ## convert nt data to aa
  chain_aa_dt <- matrix(data = NA, nrow = nrow(chainInfo), ncol = 120, byrow = TRUE)
  for(m in 1:nrow(chain_dt)){
      for(n in 1:120){
          chain_aa_dt[m, n] <- mean(chain_dt[m, (n-1)*3+1], chain_dt[m, (n-1)*3+2], chain_dt[m,(n-1)*3+3], )
      }
  }
  dt_final <- data.frame(
      length_aa= 1:120,
      median_reads= colMedians(chain_aa_dt, na.rm = T),
      up=colQuantiles(chain_aa_dt, probs = 0.75, na.rm = T),
      down=colQuantiles(chain_aa_dt, probs = 0.25, na.rm = T)
  )
  ## prepare position data for cdr rect
  cdr1_min_start <- min(chainInfo$cdr1_start_aligned)/3
  cdr1_max_end <- max(chainInfo$cdr1_end_aligned)/3
  if(is.na(cdr1_min_start) || is.na(cdr1_max_end)){
      cdr1_min_start <- cdr1_start
      cdr1_max_end <- cdr1_end
  }

  cdr2_min_start <- min(chainInfo$cdr2_start_aligned)/3
  cdr2_max_end <- max(chainInfo$cdr2_end_aligned)/3
  if(is.na(cdr2_min_start) || is.na(cdr2_max_end)){
      cdr2_min_start <- cdr2_start
      cdr2_max_end <- cdr2_end
  }
  
  cdr3_min_start <- min(chainInfo$cdr3_start_aligned)/3
  cdr3_max_end <- max(chainInfo$cdr3_end_aligned)/3
  if(is.na(cdr3_min_start) || is.na(cdr3_max_end)){
      cdr3_min_start <- cdr3_start
      cdr3_max_end <- cdr3_end
  }
  
  p <- ggplot(data = dt_final, 
              mapping = aes(x=length_aa, y = median_reads)) + 
    geom_rect(aes(xmin = cdr1_min_start, xmax = cdr1_max_end, ymin=-Inf,ymax=Inf),
              fill="lightgreen",alpha=0.3)+
    annotate(geom = "text",x=ceiling((cdr1_min_start+cdr1_max_end)/2),y = Inf,
             label="CDR1", vjust=1.5)+
    geom_rect(aes(xmin=cdr2_min_start,xmax=cdr2_max_end,ymin=-Inf,ymax=Inf),
              fill="lightgreen",alpha=0.3)+
    annotate(geom = "text",x=ceiling((cdr2_min_start+cdr2_max_end)/2),y= Inf,
             label="CDR2", vjust=1.5)+
    geom_rect(aes(xmin=cdr3_min_start,xmax=cdr3_max_end,ymin=-Inf,ymax=Inf),
              fill="lightgreen",alpha=0.3)+
    annotate(geom = "text",x=ceiling((cdr3_min_start+cdr3_max_end)/2),y = Inf,
             label="CDR3", vjust=1.5)+
    geom_line(linetype=1)+
    geom_line(mapping = aes(x=length_aa, y=up),linetype=2)+
    geom_line(mapping = aes(x=length_aa, y=down),linetype=2)+
    xlab("VDJ residual (IMGT scheme)")+ylab("UMI/Read Coverage")+
    theme_classic()
  
  if(vdj_type == "BCR_VH"){
    p <- p + ggtitle("IGH")
  }else if(vdj_type == "BCR_VL"){
    p <- p + ggtitle("IGK/L")
  }else if(vdj_type == "TCR_VH"){
    p <- p + ggtitle("TRB/D")
  }else if(vdj_type == "TCR_VL"){
    p <- p + ggtitle("TRA/G")
  }
  return(p)
}
```

```{r include = FALSE}
#A function to analysis VDJ lineages and visualization
# 
# author: yuanzhen (yuanzhen@thunder-bio.com)
#
# parameters:
#
#barcode_report: characters,file path,barcode report from trust4
#airr_report: characters,file path,airr report from trust4
#
#output
#
#a heatmap png of Variable germline gene segment pairing for B-cell repertoires
#a barplot png indicate the number of cells for the top 50 lineages
#a pie plot png indicate the number of cells for the top 50 lineages
#a csv file include the analysis information
#
#
plot_lineages=function(barcode_report_file, airr_report_file){
  
  barcode_report <- read_delim(barcode_report_file,
                               delim = "\t", escape_double = FALSE, 
                               trim_ws = TRUE,show_col_types = F)
  
  suppressWarnings(
      airr <- read_delim(airr_report_file, 
                         delim = "\t", escape_double = FALSE, 
                         trim_ws = TRUE,show_col_types = F)
  )
  

  
  save_csv=.make_clone_type(airr_fe = airr, barcode_fe = barcode_report)
  
  write_csv(save_csv,"barcode_clonetype.csv",quote = "none")
  
  ig_info_all= save_csv%>%
    distinct(.keep_all = TRUE) %>%
    group_by(ig) %>% 
    summarize(type_number = n()) %>%
    mutate(IGH=str_split(ig,"_") %>% sapply("[",1) %>% str_remove("[*][0-9]+"),
           IGL=str_split(ig,"_") %>% sapply("[",4) %>% str_remove("[*][0-9]+"))%>% 
    select(IGH,IGL,type_number) %>%
    filter(IGH!="*") %>%
    filter(IGL!="*") %>% arrange(desc(type_number))
  
  ig_info=ig_info_all%>% 
    dcast(IGH ~ IGL,value.var="type_number") %>%
    column_to_rownames(var = "IGH")
  
  ig_info=ig_info/nrow(ig_info_all)
  #######  heatmap plot ########

  dt_=data.frame(vh=ig_info%>% sapply("[",1) %>% str_remove("r"),
                 vl=ig_info%>% sapply("[",3)%>% str_remove("r")) %>% 
    mutate(ig=str_c(vh,vl)) %>% 
    group_by(ig) %>% 
    mutate(count=n())%>% 
    ungroup() %>% 
    distinct() %>% 
    select(vh,vl,count)
  
  dt_1=dt_ %>%
    pivot_wider(id_cols = vh,names_from = vl,values_from = count) %>%
    column_to_rownames("vh")
  
  dt_1= dt_1/nrow(dt_)
  dt_1[is.na(dt_1)]=0
  
  lineages_count=dt_1 %>% as.matrix()
  lineages_count=lineages_count[,colnames(lineages_count) %>% sort()]
  lineages_count=lineages_count[rownames(lineages_count) %>% sort(),]
  column_ha <- HeatmapAnnotation(
    L = anno_barplot(colSums(lineages_count),border = F),
    show_annotation_name  = F
  )
  row_ha <- rowAnnotation(
    H = anno_barplot(rowSums(lineages_count),
                     axis_param = list(direction = "reverse"),border = F),
    show_annotation_name=F)
  #lineages_count[lineages_count > 0.01]=0.01
  ph <- Heatmap(lineages_count,
            cluster_columns = F,
            cluster_rows = F,
            top_annotation = column_ha, 
            left_annotation = row_ha,
            col = RColorBrewer::brewer.pal(9,"OrRd"),
            column_names_gp = gpar(fontsize = 6),
            row_names_gp = gpar(fontsize = 4),
            heatmap_legend_param = list(title="",at=c(0,max(lineages_count)),labels=c("0",">1%"))
  )
  
  #######  barplot ########
  bar_plot=data.frame(rank=1:50,
                      number_type=ig_info_all$type_number[1:50])
  
  p2=ggplot(bar_plot, aes(x=rank,y=number_type)) + 
    geom_bar(color = 'black', fill='lightblue',stat="identity")+
    xlab("Top 50 lineages")+ylab("No. of cells per lineages")+
    theme_classic()
  
  ######## pie plot ####
  
  info = c(ig_info_all %>% filter(type_number > 1) %>% nrow(), 
           ig_info_all %>% filter(type_number == 1) %>% nrow())
  piepercent = c(paste0(round(info[1]/sum(info),4)*100,"%"), 
                 paste0(round(info[2]/sum(info),4)*100,"%"))
  names = c("Cell in expanded lineages", 
            "Cell in singleton lineages")
  
  cols = c("#3f48CC","grey")
  pie(info,labels=piepercent,col=cols)
  legend("topright", names, cex=1, fill=cols,border = "white")
}

.make_clone_type=function(airr_fe, barcode_fe){

  #airr_fe=airr_fe[!str_detect(airr_fe$sequence_id,"-"),]
  #airr_fe=airr_fe[airr_fe$productive,]
  #airr_fe=airr_fe[airr_fe$complete_vdj,]
  airr_fe$junction_length=str_length(airr_fe$junction)
  barcode_fe =filter(barcode_fe ,`#barcode` %in% airr_fe$sequence_id)
  barcode_fe=barcode_fe[!barcode_fe$chain1=="*",]
  barcode_fe=barcode_fe[!barcode_fe$chain2=="*",]
  barcode_fe$sequence_id=barcode_fe$`#barcode`
  ig_info_all_unf=data.frame(cell_id=barcode_fe$`#barcode`,
                             igh=paste0(barcode_fe$chain1 %>% str_split(",") %>% sapply("[",1),
                                        "_",
                                        barcode_fe$chain1 %>% str_split(",") %>% sapply("[",2),
                                        "_",
                                        barcode_fe$chain1 %>% str_split(",") %>% sapply("[",3)),
                             igk=paste0(barcode_fe$chain2 %>% str_split(",") %>% sapply("[",1),
                                        "_",
                                        barcode_fe$chain2 %>% str_split(",") %>% sapply("[",2),
                                        "_",
                                        barcode_fe$chain2 %>% str_split(",") %>% sapply("[",3)),
                             igh_cdr3=barcode_fe$chain1 %>% str_split(",") %>% sapply("[",6),
                             umi_length_vh=barcode_fe$chain1 %>% str_split(",") %>% sapply("[",7),
                             umi_length_vl=barcode_fe$chain2 %>% str_split(",") %>% sapply("[",7))%>%
    mutate(ig=paste0(igh,"_",igk) ) %>%
    distinct(.keep_all = TRUE) 
  
  
  ig_info_split=split(ig_info_all_unf,ig_info_all_unf$ig)
  
    ig_info_f=lapply(1:length(ig_info_split),function(i){
    xz=ig_info_split[[i]]
    if(nrow(xz)>1){
      m=xz$igh_cdr3
      yz=as.alignment(nb=length(m),nam = 1:length(m),m)
      zt=dist.alignment(yz, matrix = "identity",gap = T) %>% as.matrix()
      t=1-zt^2
      thre=1+(length(m)-1)*0.8
      if(!any(colSums(t)<thre)){
        xz
      }else{
        xz[-which(colSums(t)<thre),]
      }
    }else{
      return(xz)
    }
  })
  
  
  
  ig_info_save=lapply(1:length(ig_info_f),function(x){
    mutate(ig_info_f[[x]],clonetype=x)
  })
  ig_info_save=ig_info_save[-which(lapply(ig_info_save,nrow) %>% unlist ==0)]
  a_tt=do.call(rbind,ig_info_save)
  left_join(a_tt,airr_fe,by=join_by("cell_id"=="sequence_id"))
}
```


`r if(!include_gex){"\\begin{comment}"} else {NULL}`

```{r process_gex, include = FALSE, eval = include_gex}
is_number_string <- function(x){
    str_split(x, pattern="") %>% 
        unlist %>% str_detect("[0-9.]") %>% 
        all()
}
starsolo_summary <- read_csv(params$starsolo_out,
                             col_names = c("item", "value"),
                             col_types = cols("c", "c"))
starsolo_summary$data <- NA
for(i in 1:nrow(starsolo_summary)){
    if(is_number_string(starsolo_summary$value[i])){
        if(as.numeric(starsolo_summary$value[i]) >= 1){
            starsolo_summary$data[i] <- comma(as.numeric(starsolo_summary$value[i]), accuracy = 1)
        }else{
            starsolo_summary$data[i] <- percent(as.numeric(starsolo_summary$value[i]))
        }
    }else{
        starsolo_summary$data[i] <- starsolo_summary$value[i]
    }
}
starsolo_summary <- starsolo_summary %>%
    select(-value) %>%
    dplyr::rename("value" = "data") %>%
    mutate(item=str_replace_all(item, "GeneFull", "Gene"))
exon_cmd <- paste0("grep 'exonic' ", params$qualimap_out, " | awk '{print $NF}' | sed 's/(//; s/)//'")
exon_ratio <- system(exon_cmd, intern = TRUE)

intron_cmd <- paste0("grep 'intron' ", params$qualimap_out, " | awk '{print $NF}' | sed 's/(//; s/)//'")
intron_ratio <- system(intron_cmd, intern = TRUE)

STARSolo <- Read10X(data.dir=file.path(params$starsolo_matrixDir))
seuratData <- CreateSeuratObject(counts=STARSolo,
                             min.cells=0,
                             min.features=0, project=params$sampleName)
seuratData[['run']]=params$sampleName
seuratData[["percent.mt"]]=PercentageFeatureSet(object=seuratData, pattern = "MT-|mt-")

## save a raw loom file
SaveH5Seurat(
    seuratData, 
    filename = paste0(params$sampleName, ".raw.h5seurat"), 
    overwrite = TRUE,
    verbose = FALSE
)

## Plot the genes counts, RNAs counts and mitochondrial proportions.
qcPlot <- VlnPlot(object=seuratData, features=c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol=3, group.by="run")

## Filter by gene counts and mitochondrial percentage
## Check the number of cells left first, or subset will throw an error
filtered_cells <- seuratData@meta.data %>% 
    filter(nFeature_RNA > max(200, as.numeric(params$nFeature_RNA_lower)),
           percent.mt < as.numeric(params$percent_mt_cutoff)) %>% 
           nrow
message("filtered_cells is ", filtered_cells)
if(filtered_cells>0){
    seuratData <- subset(
        seuratData, 
        nFeature_RNA > as.numeric(params$nFeature_RNA_lower) & percent.mt < as.numeric(params$percent_mt_cutoff)
    )
    filtered_cells <- seuratData@meta.data %>% nrow
}

## Only perform clustering when more than 150 cells detected
if(filtered_cells >= 150){
    ## Normalization and scaling
    ##seuratData <- NormalizeData(object=seuratData)
    ##seuratData <- FindVariableFeatures(seuratData)
    ##seuratData <- ScaleData(seuratData, vars.to.regress=c("nCount_RNA", "percent.mt"), features=rownames(seuratData))
    
    ## replace above commands with sctransform
    ## default use top 3000 variable features
    seuratData <- SCTransform(seuratData, vars.to.regress = "percent.mt", conserve.memory = TRUE)
    
    seuratData <- RunPCA(object=seuratData, npcs=100)
    
    ## set pca_dim to be used, 30
    pca_dim <- as.numeric(params$pca_dim)
    ## set resolution
    resolution <- as.numeric(params$resolution)
    
    seuratData <- FindNeighbors(object=seuratData, reduction="pca", dims=1:pca_dim)
    seuratData <- FindClusters(object=seuratData, resolution=resolution)
    seuratData <- RunUMAP(object=seuratData, reduction="pca", dims=1:pca_dim)
    
    ##Idents(object=seuratData) <- paste("RNA_snn_res.", resolution, sep="")
    ##clusterPlot <- DimPlot(object=seuratData, reduction="umap", label=TRUE, repel=TRUE)
}
```


GEX {data-orientation=rows}
====================

<h2 style="margin-top: 0.5rem; font-weight: bold;">Sample: `r params$sampleName` (GEX)</h2>

Row
----------

### Estimated Number of Cells

```{r eval = include_gex}
cellNum <- starsolo_summary %>% 
    filter(item == "Estimated Number of Cells") %>% 
    pull(value)
valueBox(cellNum, icon = "fa-circle-notch", color = "info")
```

### Mean Reads per Cell

```{r eval = include_gex}
readsMean <- starsolo_summary %>% 
    filter(item == "Mean Reads per Cell") %>% 
    pull(value)
valueBox(readsMean, icon = "fa-chart-bar", color = "primary")
```

### Median Genes per Cell

```{r eval = include_gex}
medianGenePerCell <- starsolo_summary %>% 
    filter(str_detect(item, regex("Median Gene(Full)* per Cell"))) %>% 
    pull(value)
valueBox(medianGenePerCell, icon = "fa-barcode", color = "warning")
```

Row
----------

### Cell Stats

```{r eval = include_gex}
d <- starsolo_summary %>% 
    filter(item %in% c("Estimated Number of Cells",
                       "Unique Reads in Cells Mapped to Gene",
                       "Unique Reads in Cells Mapped to GeneFull",
                       "Reads in Cells Mapped to Gene",
                       "Fraction of Unique Reads in Cells",
                       "Fraction of Reads in Cells",
                       "Mean Reads per Cell",
                       "Median Reads per Cell",
                       "UMIs in Cells",
                       "Mean UMI per Cell",
                       "Median UMI per Cell",
                       "Mean Gene per Cell",
                       "Mean GeneFull per Cell",
                       "Median Gene per Cell",
                       "Median GeneFull per Cell",
                       "Total Gene Detected",
                       "Total GeneFull Detected"))
names(d) <- c("","")                       
d %>% kbl() %>% kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

### Knee Plot

```{r eval = include_gex}
umi_dist <- read_tsv(params$starsolo_bc, col_names =c("UMI"))
cellNum <- str_replace(cellNum, ",", "") %>% as.numeric()
umi_dist <-  umi_dist %>%
    mutate(
        cell = c(1:nrow(umi_dist)),
        group = case_when(
            cell <= cellNum ~ "cell",
            TRUE ~ "background"
            )
        )

fig <- plot_ly(data = umi_dist, x = ~cell, y = ~UMI, type = 'scatter', mode = 'lines',
               color = ~group, colors = c('grey', '#002366'),
               hovertemplate = 'UMI: %{y}<extra>%{fullData.name}</extra>',
               line = list(width = 3),
               height = 400, width = 360)
fig <- layout(fig, xaxis = list(title = "Barcode Rank", type = "log"),yaxis = list(type = "log"), showlegend = FALSE)
config_plotly_fig(fig) %>% toWebGL()

##ggplot(umi_dist, aes(x=cell, y=UMI, color = group)) + 
##    geom_point(alpha = 0.8) +
##    geom_vline(xintercept = cellNum, 
##               linetype = "dashed", color = "grey") +
##    scale_x_log10(n.breaks = 8, labels = scales::label_number_si()) + 
##    scale_y_log10(n.breaks = 5, labels = scales::label_number_si()) +
##    scale_color_manual(values =c("grey", "royalblue")) +
##    xlab("Cell") + ylab("UMI") +
##    theme_bw() + 
##    theme(panel.grid = element_blank(), 
##          axis.text = element_text(color="black"),
##          legend.position = "none")
```

Row {data-height=400}
----------

### Sequencing Stats

```{r eval = include_gex}
d <- starsolo_summary %>% 
    filter(item %in% c("Number of Reads",
                       "Reads With Valid Barcodes",
                       "Sequencing Saturation",
                       "Q30 Bases in CB+UMI",
                       "Q30 Bases in RNA read",
                       "Total Gene Detected",
                       "Total GeneFull Detected"))
names(d) <- c("","")
d %>% kbl() %>% kable_paper("hover", html_font = "arial, helvetica, sans-serif")
                                        
```

### Mapping Stats

```{r eval = include_gex}
d <- starsolo_summary %>% 
    filter(item %in% c("Reads Mapped to Genome: Unique+Multiple",
                       "Reads Mapped to Genome: Unique",
                       "Reads Mapped to Gene: Unique+Multiple Gene",
                       "Reads Mapped to GeneFull: Unique+Multiple GeneFull",
                       "Reads Mapped to Gene: Unique Gene",
                       "Reads Mapped to GeneFull: Unique GeneFull")) %>%
    add_row(item = "Reads Mapped to Exonic Regions", value = exon_ratio) %>%
    add_row(item = "Reads Mapped to Intronic Regions", value = intron_ratio)
names(d) <- c("","")
d %>% kbl() %>% kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

Row
----------

### Cell Cluster (colored by cell group)

```{r eval = include_gex}
## Only plot cluster when there are more than 150 filtered cells
if(filtered_cells >= 150){
    ##clusterPlot <- DimPlot(object=seuratData, reduction="umap", label=TRUE, repel=TRUE)
    ## extract data from seuratData
    umap_data <- Embeddings(object = seuratData[["umap"]])[colnames(seuratData), c(1, 2)]
    clusterData <- merge(umap_data, seuratData@meta.data, by=0) %>% 
        dplyr::rename("bc" = `Row.names`)
    cellCount <- clusterData %>% group_by(seurat_clusters) %>% summarise(cellCount = n())
    totalCell <- cellCount %>% pull(cellCount) %>% sum()
    clusterData <- clusterData %>% left_join(cellCount, by = "seurat_clusters") %>%
        mutate(totalCell=totalCell,
               text = paste0(cellCount, "/", totalCell))
    
    plot_ly(clusterData, x = ~UMAP_1, y= ~UMAP_2, color = ~seurat_clusters, 
            text = ~text,
            type = 'scatter', mode = 'markers',
            colors = 'Dark2',
            hovertemplate = 'cells: %{text}<extra><b>Cluster: %{fullData.name}</b></extra>') %>%
        config_plotly_fig() %>%
        toWebGL()
    
    ##clusterPlot %>% ggplotly() %>%
    ##    config(displaylogo = FALSE,
    ##           modeBarButtonsToRemove = c('zoom', 'pan', 'select', 'zoomIn', 'zoomOut', 'autoScale',
    ##                                      'hoverClosestCartesian', 'hoverCompareCartesian')) %>% toWebGL()
}else{
    cat("Too few cells: ", filtered_cells, "(filtered by nFeature >= 200)\n")
}
```

### Cell Cluster (colored by read depth)

```{r eval = include_gex}
if(filtered_cells >= 150){
clusterData <- clusterData %>%
    mutate(log10_UMI = log10(nCount_RNA))
    
plot_ly(clusterData, x = ~UMAP_1, y= ~UMAP_2, color = ~log10_UMI,  text = ~nCount_RNA,
        type = 'scatter', mode = 'markers',
        hovertemplate = 'UMI: %{text}<extra></extra>') %>%
    config_plotly_fig() %>%
    toWebGL()

##depthPlot <- FeaturePlot(object = seuratData, features = 'log_nCount_RNA') + scale_color_continuous(name="log10 Read Counts", type = "viridis", direction = 1) + labs(title = NULL)
##depthPlot %>% ggplotly() %>%
##    config(displaylogo = FALSE, 
##           modeBarButtonsToRemove = c('zoom', 'pan', 'select', 'zoomIn', 'zoomOut', 'autoScale',
##                                      'hoverClosestCartesian', 'hoverCompareCartesian')) %>% toWebGL()
}else{
    cat("Too few cells: ", filtered_cells, "(filtered by nFeature >= 200)\n")
}
```

Row {style="margin-right: 8px"}
----------

### Marker Genes of Clusters (top5) {style="width: 100% !important"}

```{r eval = include_gex}
if(filtered_cells >= 150){
    markerGenes <- FindAllMarkers(seuratData, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
    if("cluster" %in% colnames(markerGenes)){
        markerGenes %>%
            group_by(cluster) %>%
            slice_max(n = 5, order_by = avg_log2FC) %>% 
            dplyr::relocate(gene, .before=1) %>%
            mutate(p_val = signif(p_val, 3),
                   avg_log2FC = signif(avg_log2FC, 3),
                   p_val_adj = signif(p_val_adj, 3)) %>%
            DT::datatable(rownames = FALSE, width = "100%",
                          options = list(scrollX = T, scrollY = F, pageLength = 10))
    }else{
        cat("No DEGs detected.\n")
    }
}else{
    cat("Too few cells: ", filtered_cells, "(filtered by nFeature >= 200)\n")
}
```

```{r include=FALSE, eval = include_gex}
if(filtered_cells >= 150 && ("cluster" %in% colnames(markerGenes))){
    markerGenes %>%
        group_by(cluster) %>%
        dplyr::relocate(gene, .before=1) %>%
        write_tsv(paste0(params$sampleName, "_DEG.tsv"))
}
```

Row
----------

### Cell Metrics

```{r eval = include_gex}
qcPlot
```

### Gene Coverage

```{r eval = include_gex}
read_tsv(params$qualimap_gene_coverage) %>%
    ggplot(aes(x=`#Transcript position`, y=`Transcript coverage profile`)) +
    geom_line(size=1, color = "#551a8b", alpha=0.8) +
    scale_y_continuous(labels = label_comma()) +
    theme_bw() + theme(panel.grid = element_blank())
```


Row
----------

### Sequencing Saturation

```{r eval = include_gex}
saturation_data <- fromJSON(params$saturation_json)
saturation_data <- saturation_data[["saturation_data"]] %>%
    as_tibble() %>%
    mutate(across(.col = everything(), .fns = as.numeric))

plot_ly(saturation_data, x = ~reads, y= ~saturation,
        type = 'scatter', mode = 'lines',
        hovertemplate = 'Read depth: %{x}<br>Saturation: %{y}<extra></extra>') %>%
    config_plotly_fig() %>%
    toWebGL()
```

### Median Genes per Cell

```{r eval = include_gex}
plot_ly(saturation_data, x = ~meanReadPerCell, y= ~medianGenePerCell,
        type = 'scatter', mode = 'lines',
        hovertemplate = 'Mean read per cell: %{x}<br>Median gene per cell: %{y}<extra></extra>') %>%
    config_plotly_fig() %>%
    toWebGL()
```

```{r include=FALSE, eval = include_gex}
starsolo_summary %>% 
    filter(item %in% c("Estimated Number of Cells",
                       "Unique Reads in Cells Mapped to Gene",
                       "Unique Reads in Cells Mapped to GeneFull",
                       "Fraction of Unique Reads in Cells",
                       "Mean Reads per Cell",
                       "Median Reads per Cell",
                       "UMIs in Cells",
                       "Mean UMI per Cell",
                       "Median UMI per Cell",
                       "Mean Gene per Cell",
                       "Mean GeneFull per Cell",
                       "Median Gene per Cell",
                       "Median GeneFull per Cell",
                       "Total Gene Detected",
                       "Total GeneFull Detected",
                       "Number of Reads",
                       "Reads With Valid Barcodes",
                       "Sequencing Saturation",
                       "Q30 Bases in CB+UMI",
                       "Q30 Bases in RNA read",
                       "Reads Mapped to Genome: Unique+Multiple",
                       "Reads Mapped to Genome: Unique",
                       "Reads Mapped to Gene: Unique+Multiple Gene",
                       "Reads Mapped to GeneFull: Unique+Multiple GeneFull",
                       "Reads Mapped to Gene: Unique Gene",
                       "Reads Mapped to GeneFull: Unique GeneFull")) %>%
    add_row(item = "Reads Mapped to Exonic Regions", value = exon_ratio) %>%
    add_row(item = "Reads Mapped to Intronic Regions", value = intron_ratio) %>%
    mutate(sampleID=params$sampleName) %>% 
    pivot_wider(sampleID, names_from = item, values_from= value) %>% 
    write_json(paste0(params$sampleName, ".metrics.json"), pretty=TRUE)
```

`r if(!include_gex) {"\\end{comment}"} else {NULL}`

`r if(!include_tcr) {"\\begin{comment}"} else {NULL}`

VDJ-T {data-orientation=rows}
====================

<h2 style="margin-top: 0.5rem; font-weight: bold;">Sample: `r params$sampleName` (VDJ-T)</h2>

```{r include=FALSE, eval = include_tcr}
vdj_t_cloneType <- read_tsv(params$VDJ_T_cloneType) %>%
    arrange(desc(CellCount))
vdj_t_cloneType <- vdj_t_cloneType %>%
    mutate(id = 1:nrow(vdj_t_cloneType),
           Frequency = scales::label_percent(0.01)(Frequency))
```

Row
----------

### Estimated Number of Cells


```{r include = FALSE, eval = include_tcr}
vdj_t_metrics <- fromJSON(params$VDJ_T_metrics)
## write metrics to tsv
fromJSON(params$VDJ_T_metrics) %>% 
    as.data.frame %>% t() %>% as.data.frame() %>% 
    rownames_to_column("term") %>% 
    write_tsv(paste0(params$sampleName, "_VDJ-T.metrics.tsv"), col_names=FALSE)
```

```{r eval = include_tcr}
valueBox(vdj_t_metrics$cells %>% as.numeric() %>% label_comma()(), icon = "fa-circle-notch", color = "info")
```

### Mean VDJ Reads per Cell

```{r eval = include_tcr}
valueBox(vdj_t_metrics$meanVDJReadsPerCell %>% as.numeric() %>% round %>% label_comma()(), icon = "fa-chart-bar", color = "primary")
```

### Total Clonetypes Discovered

```{r eval = include_tcr}
valueBox(nrow(vdj_t_cloneType) %>% label_comma()(), icon = "fa-barcode", color = "warning")
```

Row
----------

### VDJ Stats

```{r eval = include_tcr}
##Estimated Number of Cells
##Reads in Cells Mapped to Gene
##Fraction of Reads in Cells
##Mean Reads per Cell
##Median Reads per Cell
##UMIs in Cells
##Mean UMI per Cell
##Median UMI per Cell
##Mean Gene per Cell
##Median Gene per Cell

fractionAssembled <- as.numeric(vdj_t_metrics$totalReadsInCell)/(as.numeric(vdj_t_metrics$totalRawReads)*as.numeric(vdj_t_metrics$validBCreads))
fractionAssembled <- as.character(fractionAssembled)

vdj_t_tbl <- tribble(
  ~term, ~value,
  "Estimated Number of Cells (including non-pairing cells)", vdj_t_metrics$cells,
  "Reads in Cells Mapped to VDJ Gene", vdj_t_metrics$totalReadsInCell,
  "Fraction of Reads Used in Assembly", fractionAssembled,
  "Mean VDJ Reads per Cell", vdj_t_metrics$meanVDJReadsPerCell,
  "Median VDJ Reads per Cell", vdj_t_metrics$medianVDJReadsPerCell,
  "Mean Total UMIs per Cell", vdj_t_metrics$meanTotalUMIsPerCell,
  "Median Total UMIs per Cell", vdj_t_metrics$medianTotalUMIsPerCell,
  "Pairing Rate", vdj_t_metrics$pairingRate,
  "Total Clone Types Detected", vdj_t_metrics$totalCloneTypes
) %>%
  mutate(value = as.numeric(value)) %>%
  mutate(value=case_when(value <= 1 ~ label_percent(0.01)(value),
                         value > 1 ~ label_comma()(round(value))))
                         
## Rename UMI terms
if(!params$withUMI){
    vdj_t_tbl$term[which(vdj_t_tbl$term=="Mean Total UMIs per Cell")] <- "Mean Total Reads per Cell"
    vdj_t_tbl$term[which(vdj_t_tbl$term=="Median Total UMIs per Cell")] <- "Median Total Reads per Cell"
}

names(vdj_t_tbl) <- c("", "")
vdj_t_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

### Knee Plot

```{r eval = include_tcr}
cellNum <- as.numeric(vdj_t_metrics$cells)
vdj_t_kneeData <- read_tsv(params$VDJ_T_kneeOut, col_names = c("CB", "UMI"))
vdj_t_cells <- read_tsv(params$VDJ_T_cells)
vdj_t_knee <- vdj_t_kneeData %>% 
    mutate(
        cell = c(1:nrow(vdj_t_kneeData)),
        group = case_when(
            CB %in% vdj_t_cells$CB ~ "cell",
            TRUE ~ "background"
        )
    )
fig <- plot_ly(data = vdj_t_knee, x = ~cell, y = ~UMI, type = 'scatter', mode = 'lines',
               color = ~group, colors = c('grey', '#002366'),
               hovertemplate = 'UMI: %{y}<extra>%{fullData.name}</extra>',
               line = list(width = 3),
               height = 400, width = 360)
fig <- layout(fig, xaxis = list(title = "Barcode Rank", type = "log"),yaxis = list(type = "log"), showlegend = FALSE)

if(!params$withUMI){
    fig <- layout(fig, yaxis = list(title = "Reads"))
}

config_plotly_fig(fig) %>% toWebGL()
```

Row {data-height=350}
----------

### Sequencing Stats

```{r eval = include_tcr}
##Number of Reads
##Reads With Valid Barcodes
##Sequencing Saturation
##Q30 Bases in CB+UMI
##Q30 Bases in RNA read
##Total VDJ Gene Fragments Detected
vdj_t_tbl <- tribble(
  ~term, ~value,
  "Number of Reads", vdj_t_metrics$totalRawReads,
  "Reads With Valid Barcodes", vdj_t_metrics$validBCreads,
  "Sequencing Saturation", vdj_t_metrics$saturation,
  "Q30 Bases in CB+UMI", vdj_t_metrics$q30InCBandUMI,
  "Q30 Bases in RNA read", vdj_t_metrics$q30InRNA
) %>%
  mutate(value = as.numeric(value)) %>%
  mutate(value=case_when(value <= 1 ~ label_percent(0.01)(value),
                         value > 1 ~ label_comma()(round(value))))
names(vdj_t_tbl) <- c("", "")
vdj_t_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

### V(D)J Annotation

```{r eval = include_tcr}
##Cells with productive V-J spanning pair
##Cells with productive V-J spanning (IGK, IGH) pair
##Cells with productive V-J spanning (IGL, IGH) pair
##Cells with productive IGH contig
##Cells with productive IGK contig
##Cells with productive IGL contig
##Paired clonotype diversity
vdj_t_tbl <- tribble(
  ~term, ~value,
  "Median TRB/TRD UMIs per Cell", vdj_t_metrics$medianUMIsChain1,
  "Median TRA/TRG UMIs per Cell", vdj_t_metrics$medianUMIsChain2,
  "Cells with Productive TRB", vdj_t_metrics$cellsWithProductiveChainTRB,
  "Cells with Productive TRD", vdj_t_metrics$cellsWithProductiveChainTRD,
  "Cells with Productive TRA", vdj_t_metrics$cellsWithProductiveChainTRA,
  "Cells with Productive TRG", vdj_t_metrics$cellsWithProductiveChainTRG,
  "Cells with Productive TRATRB pair", vdj_t_metrics$cellsWithProductiveChainTRATRB,
  "Cells with Productive TRGTRD pair", vdj_t_metrics$cellsWithProductiveChainTRGTRD
) %>%
  mutate(value = as.numeric(value)) %>%
  mutate(value=case_when(value <= 1 ~ label_percent(0.01)(value),
                         value > 1 ~ label_comma()(round(value))))
names(vdj_t_tbl) <- c("", "")
vdj_t_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

Row
----------

### GEX Association

```{r eval = (include_tcr & include_gex)}
## Only plot cluster when there are more than 150 filtered cells
if(filtered_cells >= 150){
    ##clusterPlot <- DimPlot(object=seuratData, reduction="umap", label=TRUE, repel=TRUE)
    ## extract data from seuratData
    tcr_cdrSeq <- read_tsv(params$VDJ_T_report) %>%
        select(`#barcode`, `chain1`, `chain2`)
    tcr_cdrSeq$chain1_cdr3 <- ""
    tcr_cdrSeq$chain2_cdr3 <- ""
    for(i in 1:nrow(tcr_cdrSeq)){
        tcr_cdrSeq$chain1_cdr3[i] <- unlist(strsplit(tcr_cdrSeq$chain1[i], ","))[6]
        tcr_cdrSeq$chain2_cdr3[i] <- unlist(strsplit(tcr_cdrSeq$chain2[i], ","))[6]
    }
    
    tcr_cells <- vdj_t_knee %>%
        filter(group == "cell") %>%
        pull(CB)
    tcr_data <- vdj_t_kneeData %>%
        filter(CB %in% tcr_cells) %>%
        left_join(tcr_cdrSeq, by = c("CB" = "#barcode"))
    clusterData2 <- clusterData %>% left_join(tcr_data, by = c("bc" = "CB")) %>%
        dplyr::select(bc, UMAP_1, UMAP_2, chain1_cdr3, chain2_cdr3) %>%
        dplyr::mutate(
            text = paste0(chain1_cdr3, "+", chain2_cdr3),
            type = case_when(
                !is.na(chain1_cdr3) & !is.na(chain2_cdr3) ~ "Detected",
                TRUE ~ "Not captured"
            )
        )

    plot_ly(clusterData2, x = ~UMAP_1, y= ~UMAP_2, color = ~type, 
            text = ~text,
            type = 'scatter', mode = 'markers',
            marker = list(opacity = 0.5),
            colors = c("#9370DB", "grey"),
            hovertemplate = 'CDR3: %{text}<extra><b>Type: %{fullData.name}</b></extra>') %>%
        config_plotly_fig() %>%
        toWebGL()
    
    ##clusterPlot %>% ggplotly() %>%
    ##    config(displaylogo = FALSE,
    ##           modeBarButtonsToRemove = c('zoom', 'pan', 'select', 'zoomIn', 'zoomOut', 'autoScale',
    ##                                      'hoverClosestCartesian', 'hoverCompareCartesian')) %>% toWebGL()
}else{
    cat("Too few cells: ", filtered_cells, "(filtered by nFeature >= 200)\n")
}
```

```{r eval = !(include_tcr & include_gex)}
cat("No gene expression library\n")
```

### Top 10 Clonetypes

```{r eval = include_tcr}
fig <- plot_ly(data = vdj_t_cloneType %>% filter(id<=10), x = ~id, y = ~CellCount, type = "bar")
fig <- layout(fig, showlegend = FALSE)
config_plotly_fig(fig)
```

Row {style="margin-right: 8px"}
----------

### Identified Clonetypes (top 1000) {style="width: 100% !important"}

```{r eval = include_tcr}
vdj_t_cloneType %>%
    filter(id <= 1000) %>%
    DT::datatable(rownames = FALSE, width = "100%",
                  options = list(scrollX = T, scrollY = F, pageLength = 10))
```

Row {data-height=400}
----------

### V Region Coverage (Chain1)

```{r eval = include_tcr, fig.width = 7, fig.height = 4}
coverage_plots <- plot_VDJ_coverage(
    cells = vdj_t_cells$CB, 
    barcode_report = params$VDJ_T_report, 
    airr_report = params$VDJ_T_airr, 
    trust4_final_out = params$VDJ_T_finalOut, 
    type = "VDJ-T"
)
coverage_plots$chain1_plot
```

### V Region Coverage (Chain2)


```{r eval = include_tcr, fig.width = 7, fig.height = 4}
coverage_plots$chain2_plot
```

Row
----------

### Lineage Stats

```{r eval = include_tcr}
tcr_lineageInfo <- getLineage(cells = vdj_t_cells$CB,
                              barcode_report = params$VDJ_T_report)
tcr_pairing_clones <- tcr_lineageInfo %>%
    select(chain1_V, chain1_D, chain1_J, chain1_cdr3,
           chain2_V, chain2_J, chain2_cdr3) %>%
    distinct() %>%
    nrow()
tcr_lineage_number <- tcr_lineageInfo %>%
    pull(lineageName) %>%
    unique() %>% length()
multipleLineageCellNumber <- tcr_lineageInfo %>%
    filter(lineageType == "multiple") %>%
    nrow()
multipleCellLineageNumber <- tcr_lineageInfo %>%
    filter(lineageType == "multiple") %>%
    pull(lineageName) %>%
    unique() %>% length()
singleCellLineageNumber <- tcr_lineageInfo %>%
    filter(lineageType == "single") %>%
    pull(lineageName) %>%
    unique() %>% length()
lineage_tbl <- tribble(
    ~term, ~value,
    "Clones (paired)", tcr_pairing_clones,
    "Lineage Number", tcr_lineage_number,
    "Single Cell Lineage Number", singleCellLineageNumber,
    "Multiple Cell Lineage Number", multipleCellLineageNumber,
    "Cells in Multiple Cell Lineages", multipleLineageCellNumber,
    "Total Cells with Paired Clones", nrow(tcr_lineageInfo)
)
   
names(lineage_tbl) <- c("", "")
lineage_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

### Lineage Plots


```{r eval = include_tcr, echo=FALSE, out.width="49%", fig.show="hold"}
info = c(tcr_lineageInfo %>% filter(lineageType == "single") %>% nrow(), 
         tcr_lineageInfo %>% filter(lineageType == "multiple") %>% nrow())
piepercent = c(paste0(round(info[1]/sum(info),4)*100,"%"), 
               paste0(round(info[2]/sum(info),4)*100,"%"))
names = c("Cell in Expanded Lineages", 
          "Cell in Singleton Lineages")

LineageCellNumber <- tcr_lineageInfo %>% 
    filter(lineageType == "multiple") %>%
    group_by(LineageName) %>%
    summarize(count = n()) %>%
    arrange(desc(count))

if(nrow(LineageCellNumber)>50){
    LineageCellNumber <- LineageCellNumber[1:50, ]
}
bar_plot = data.frame(rank=1:nrow(LineageCellNumber),
                      cellNum = LineageCellNumber$count)

cols = c("#3f48CC","grey")
pie(info,labels=piepercent,col=cols)
legend("bottom", inset = -0.02, names, cex=0.7, fill= cols, border = "white", text.width = strwidth("cells in singleton lineages"))
barplot(bar_plot$cellNum, names.arg = bar_plot$rank, xlab = "Multi-cell Lineages", ylab = "Cell Count", col = "#3f48CC")
```


`r if(!include_tcr) {"\\end{comment}"} else {NULL}`

`r if(!include_bcr) {"\\begin{comment}"} else {NULL}`

VDJ-B {data-orientation=rows}
====================

<h2 style="margin-top: 0.5rem; font-weight: bold;">Sample: `r params$sampleName` (VDJ-B)</h2>


```{r include=FALSE, eval = include_bcr}
vdj_b_cloneType <- read_tsv(params$VDJ_B_cloneType) %>%
    arrange(desc(CellCount))
vdj_b_cloneType <- vdj_b_cloneType %>%
    mutate(id = 1:nrow(vdj_b_cloneType),
           Frequency = scales::label_percent(0.01)(Frequency))
```

Row
----------

### Estimated Number of Cells


```{r include = FALSE, eval = include_bcr}
vdj_b_metrics <- fromJSON(params$VDJ_B_metrics)
fromJSON(params$VDJ_B_metrics) %>% 
    as.data.frame %>% t() %>% as.data.frame() %>% 
    rownames_to_column("term") %>% 
    write_tsv(paste0(params$sampleName, "_VDJ-B.metrics.tsv"), col_names=FALSE)
```

```{r eval = include_bcr}
valueBox(vdj_b_metrics$cells %>% as.numeric() %>% label_comma()(), icon = "fa-circle-notch", color = "info")
```

### Mean VDJ Reads per Cell

```{r eval = include_bcr}
valueBox(vdj_b_metrics$meanVDJReadsPerCell %>% as.numeric() %>% round %>% label_comma()(), icon = "fa-chart-bar", color = "primary")
```

### Total Clonetypes Discovered

```{r eval = include_bcr}
valueBox(nrow(vdj_b_cloneType) %>% label_comma()(), icon = "fa-barcode", color = "warning")
```

Row
----------

### VDJ Stats

```{r eval = include_bcr}
##Estimated Number of Cells
##Reads in Cells Mapped to Gene
##Fraction of Reads in Cells
##Mean Reads per Cell
##Median Reads per Cell
##UMIs in Cells
##Mean UMI per Cell
##Median UMI per Cell
##Mean Gene per Cell
##Median Gene per Cell

fractionAssembled <- as.numeric(vdj_b_metrics$totalReadsInCell)/(as.numeric(vdj_b_metrics$totalRawReads)*as.numeric(vdj_b_metrics$validBCreads))
fractionAssembled <- as.character(fractionAssembled)

vdj_b_tbl <- tribble(
  ~term, ~value,
  "Estimated Number of Cells (including non-pairing cells)", vdj_b_metrics$cells,
  "Reads in Cells Mapped to VDJ Gene", vdj_b_metrics$totalReadsInCell,
  "Fraction of Reads Used in Assembly", fractionAssembled,
  "Mean VDJ Reads per Cell", vdj_b_metrics$meanVDJReadsPerCell,
  "Median VDJ Reads per Cell", vdj_b_metrics$medianVDJReadsPerCell,
  "Mean Total UMIs per Cell", vdj_b_metrics$meanTotalUMIsPerCell,
  "Median Total UMIs per Cell", vdj_b_metrics$medianTotalUMIsPerCell,
  "Pairing Rate", vdj_b_metrics$pairingRate,
  "Total Clone Types Detected", vdj_b_metrics$totalCloneTypes
) %>%
  mutate(value = as.numeric(value)) %>%
  mutate(value=case_when(value <= 1 ~ label_percent(0.01)(value),
                         value > 1 ~ label_comma()(round(value))))
## Rename UMI terms
if(!params$withUMI){
    vdj_b_tbl$term[which(vdj_b_tbl$term=="Mean Total UMIs per Cell")] <- "Mean Total Reads per Cell"
    vdj_b_tbl$term[which(vdj_b_tbl$term=="Median Total UMIs per Cell")] <- "Median Total Reads per Cell"
}

names(vdj_b_tbl) <- c("", "")
vdj_b_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

### Knee Plot

```{r eval = include_bcr}
cellNum <- as.numeric(vdj_b_metrics$cells)
vdj_b_kneeData <- read_tsv(params$VDJ_B_kneeOut, col_names = c("CB", "UMI"))
vdj_b_cells <- read_tsv(params$VDJ_B_cells)
vdj_b_knee <- vdj_b_kneeData %>% 
    mutate(
        cell = c(1:nrow(vdj_b_kneeData)),
        group = case_when(
            CB %in% vdj_b_cells$CB ~ "cell",
            TRUE ~ "background"
        )
    )
fig <- plot_ly(data = vdj_b_knee, x = ~cell, y = ~UMI, type = 'scatter', mode = 'lines',
               color = ~group, colors = c('grey', '#002366'),
               hovertemplate = 'UMI: %{y}<extra>%{fullData.name}</extra>',
               line = list(width = 3),
               height = 400, width = 360)

fig <- layout(fig, xaxis = list(title = "Barcode Rank", type = "log"),yaxis = list(type = "log"), showlegend = FALSE)

if(!params$withUMI){
    fig <- layout(fig, yaxis = list(title = "Reads"))

}
config_plotly_fig(fig) %>% toWebGL()
```

Row {data-height=350}
----------

### Sequencing Stats

```{r eval = include_bcr}
##Number of Reads
##Reads With Valid Barcodes
##Sequencing Saturation
##Q30 Bases in CB+UMI
##Q30 Bases in RNA read
##Total VDJ Gene Fragments Detected

vdj_b_tbl <- tribble(
  ~term, ~value,
  "Number of Reads", vdj_b_metrics$totalRawReads,
  "Reads With Valid Barcodes", vdj_b_metrics$validBCreads,
  "Sequencing Saturation", vdj_b_metrics$saturation,
  "Q30 Bases in CB+UMI", vdj_b_metrics$q30InCBandUMI,
  "Q30 Bases in RNA read", vdj_b_metrics$q30InRNA
) %>%
  mutate(value = as.numeric(value)) %>%
  mutate(value=case_when(value <= 1 ~ label_percent(0.01)(value),
                         value > 1 ~ label_comma()(round(value))))
names(vdj_b_tbl) <- c("", "")
vdj_b_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

### V(D)J Annotation

```{r eval = include_bcr}
##Cells with productive V-J spanning pair
##Cells with productive V-J spanning (IGK, IGH) pair
##Cells with productive V-J spanning (IGL, IGH) pair
##Cells with productive IGH contig
##Cells with productive IGK contig
##Cells with productive IGL contig
##Paired clonotype diversity
vdj_b_tbl <- tribble(
  ~term, ~value,
  "Median IGH UMIs per Cell", vdj_b_metrics$medianUMIsChain1,
  "Median IGK/L UMIs per Cell", vdj_b_metrics$medianUMIsChain2,
  "Cells with Productive IGH", vdj_b_metrics$cellsWithProductiveChainIGH,
  "Cells with Productive IGK", vdj_b_metrics$cellsWithProductiveChainIGK,
  "Cells with Productive IGL", vdj_b_metrics$cellsWithProductiveChainIGL,
  "Cells with Productive IGKIGH pair", vdj_b_metrics$cellsWithProductiveChainIGKIGH,
  "Cells with Productive IGLIGH pair", vdj_b_metrics$cellsWithProductiveChainIGLIGH
) %>%
  mutate(value = as.numeric(value)) %>%
  mutate(value=case_when(value <= 1 ~ label_percent(0.01)(value),
                         value > 1 ~ label_comma()(round(value))))
names(vdj_b_tbl) <- c("", "")
vdj_b_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

Row
----------

### GEX Association

```{r eval = (include_bcr & include_gex)}
## Only plot cluster when there are more than 150 filtered cells
if(filtered_cells >= 150){
    ##clusterPlot <- DimPlot(object=seuratData, reduction="umap", label=TRUE, repel=TRUE)
    bcr_cdrSeq <- read_tsv(params$VDJ_B_report) %>%
        select(`#barcode`, `chain1`, `chain2`)
    bcr_cdrSeq$chain1_cdr3 <- ""
    bcr_cdrSeq$chain2_cdr3 <- ""
    for(i in 1:nrow(bcr_cdrSeq)){
        bcr_cdrSeq$chain1_cdr3[i] <- unlist(strsplit(bcr_cdrSeq$chain1[i], ","))[6]
        bcr_cdrSeq$chain2_cdr3[i] <- unlist(strsplit(bcr_cdrSeq$chain2[i], ","))[6]
    }
    ## extract data from seuratData
    bcr_cells <- vdj_b_knee %>%
        filter(group == "cell") %>%
        pull(CB)
    bcr_data <- vdj_b_kneeData %>%
        filter(CB %in% bcr_cells) %>%
        left_join(bcr_cdrSeq, by = c("CB" = "#barcode"))
    clusterData2 <- clusterData %>% left_join(bcr_data, by = c("bc" = "CB")) %>%
        dplyr::select(bc, UMAP_1, UMAP_2, chain1_cdr3, chain2_cdr3) %>%
        dplyr::mutate(
            text = paste0(chain1_cdr3, "+", chain2_cdr3),
            type = case_when(
                !is.na(chain1_cdr3) & !is.na(chain2_cdr3) ~ "Detected",
                TRUE ~ "Not captured"
            )
        )

    plot_ly(clusterData2, x = ~UMAP_1, y= ~UMAP_2, color = ~type, 
            text = ~text,
            type = 'scatter', mode = 'markers',
            marker = list(opacity = 0.5),
            colors = c("#9370DB", "grey"),
            hovertemplate = 'CDR3: %{text}<extra><b>Type: %{fullData.name}</b></extra>') %>%
        config_plotly_fig() %>%
        toWebGL()
    
    ##clusterPlot %>% ggplotly() %>%
    ##    config(displaylogo = FALSE,
    ##           modeBarButtonsToRemove = c('zoom', 'pan', 'select', 'zoomIn', 'zoomOut', 'autoScale',
    ##                                      'hoverClosestCartesian', 'hoverCompareCartesian')) %>% toWebGL()
}else{
    cat("Too few cells: ", filtered_cells, "(filtered by nFeature >= 200)\n")
}
```

```{r eval = !(include_bcr & include_gex)}
cat("No gene expression library\n")
```

### Top 10 Clonetypes

```{r eval = include_bcr}
fig <- plot_ly(data = vdj_b_cloneType %>% filter(id<=10), x = ~id, y = ~CellCount, type = "bar")
fig <- layout(fig, showlegend = FALSE)
config_plotly_fig(fig)
```

Row {style="margin-right: 8px"}
----------

### Identified Clonetypes (top 1000) {style="width: 100% !important"}

```{r eval = include_bcr}
vdj_b_cloneType %>%
    filter(id <= 1000) %>%
    DT::datatable(rownames = FALSE, width = "100%",
                  options = list(scrollX = T, scrollY = F, pageLength = 10))
```

Row {data-height=400}
----------

### V Region Coverage (Chain1)

```{r eval = include_bcr, fig.width = 7, fig.height = 4}
coverage_plots <- plot_VDJ_coverage(
    cells = vdj_b_cells$CB, 
    barcode_report = params$VDJ_B_report, 
    airr_report = params$VDJ_B_airr, 
    trust4_final_out = params$VDJ_B_finalOut, 
    type = "VDJ-B"
)
coverage_plots$chain1_plot
```

### V Region Coverage (Chain2)


```{r eval = include_bcr, fig.width = 7, fig.height = 4}
coverage_plots$chain2_plot
```

Row
----------

### Lineage Stats

```{r eval = include_bcr}
bcr_lineageInfo <- getLineage(cells = vdj_b_cells$CB,
                              barcode_report = params$VDJ_B_report)
bcr_pairing_clones <- bcr_lineageInfo %>%
    select(chain1_V, chain1_D, chain1_J, chain1_cdr3,
           chain2_V, chain2_J, chain2_cdr3) %>%
    distinct() %>%
    nrow()
bcr_lineage_number <- bcr_lineageInfo %>%
    pull(lineageName) %>%
    unique() %>% length()
multipleLineageCellNumber <- bcr_lineageInfo %>%
    filter(lineageType == "multiple") %>%
    nrow()
multipleCellLineageNumber <- bcr_lineageInfo %>%
    filter(lineageType == "multiple") %>%
    pull(lineageName) %>%
    unique() %>% length()
singleCellLineageNumber <- bcr_lineageInfo %>%
    filter(lineageType == "single") %>%
    pull(lineageName) %>%
    unique() %>% length()
lineage_tbl <- tribble(
    ~term, ~value,
    "Clones (paired)", bcr_pairing_clones,
    "Lineage Number", bcr_lineage_number,
    "Single Cell Lineage Number", singleCellLineageNumber,
    "Multiple Cell Lineage Number", multipleCellLineageNumber,
    "Cells in Multiple Cell Lineages", multipleLineageCellNumber,
    "Total Cells with Paired Clones", nrow(bcr_lineageInfo)
)
   
names(lineage_tbl) <- c("", "")
lineage_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

### Lineage Plots


```{r eval = include_bcr, echo=FALSE, out.width="49%", fig.show="hold"}
info = c(bcr_lineageInfo %>% filter(lineageType == "single") %>% nrow(), 
         bcr_lineageInfo %>% filter(lineageType == "multiple") %>% nrow())
piepercent = c(paste0(round(info[1]/sum(info),4)*100,"%"), 
               paste0(round(info[2]/sum(info),4)*100,"%"))
names = c("Cell in Expanded Lineages", 
          "Cell in Singleton Lineages")

LineageCellNumber <- bcr_lineageInfo %>% 
    filter(lineageType == "multiple") %>%
    group_by(lineageName) %>%
    summarize(count = n()) %>%
    arrange(desc(count))

if(nrow(LineageCellNumber)>50){
    LineageCellNumber <- LineageCellNumber[1:50, ]
}
bar_plot = data.frame(rank=1:nrow(LineageCellNumber),
                      cellNum = LineageCellNumber$count)

cols = c("#3f48CC","grey")
pie(info,labels=piepercent,col=cols)
legend("bottom", inset = -0.02, names, cex=0.7, fill= cols, border = "white", text.width = strwidth("cells in singleton lineages"))

barplot(bar_plot$cellNum, names.arg = bar_plot$rank, xlab = "Multi-cell Lineages", ylab = "Cell Count", col = "#3f48CC")
```


`r if(!include_bcr) {"\\end{comment}"} else {NULL}`

Running Info {data-orientation=rows}
====================

Row {data-height=600}
----------

### Running Information

```{r}
version_info <- fromJSON(params$version_json)

if(include_gex){
    cellCallingMethod <- version_info$soloCellFilter
}else{
    cellCallingMethod <- "cellRanger 2.2"
}
version_tbl <- tribble(
  ~term, ~value,
  "Sample ID", params$sampleName,
  "Pipeline Version", version_info$pipeline_version,
  "Reference Dir", version_info$referenceDir,
  "Reference GTF", version_info$referenceGTF,
  "Whitelist", version_info$whitelist,
  "VDJ Assembled with Only cDNA Reads", version_info$assembleWithcDNAreadOnly,
  "STAR Version", version_info$STAR_version,
  "Whitelist Matching", version_info$soloCBmatchWLtype,
  "UMIfiltering", version_info$soloUMIfiltering,
  "UMIdedup", version_info$soloUMIdedup,
  "Cell Calling", cellCallingMethod,
  "includeIntron", version_info$includeIntron,
  "includeMultiReads", version_info$includeMultiReads
)
if(!params$withUMI){
    version_tbl <- version_tbl %>%
        filter(!(term %in%c("UMIfiltering", "UMIdedup")))
}
if(!include_gex){
    version_tbl <- version_tbl %>%
        filter(!(term %in%c("includeIntron", "includeMultiReads")))
}
names(version_tbl) <- c("", "")
version_tbl %>% 
    kbl() %>% 
    kable_paper("hover", html_font = "arial, helvetica, sans-serif")
```

```{js}
// set knee plot margin to auto
$( document ).ready(function() {
    document.querySelectorAll("div.plot-container > div.svg-container").forEach(el => el.style.margin = "auto");
});
```